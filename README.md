# 프록시 패턴 / 데코레이터 패턴 정리!

## 들어가기 전에...
원본 코드를 수정하지 않고, 로그를 남기는 부가기능 코드를 추가하기 위해 '프록시' 개념을 도입해야 한다고 배웠다. 
프록시가 제공하는 기능은 크게 2가지다. 
- 접근 제어(권한에 따른 접근 차단, 캐싱)
- 부가 기능 추가


### 디자인 패턴의 가장 큰 차이는 "의도" 라고 했다.
> 프록시 패턴 의도 : 다른 개체에 대한 접근을 제어(캐싱)하기 위해 프록시를 제공
> 
> 데코레이터 패턴 의도 : 객체에 추가 책임(기능)을 동적으로 추가하고, 기능 확장을 위한 유연한 대안 제공 

### @Transactional 어노테이션의 동작 원리 
스프링이 지원하는 프록시, 빈 후처리기 내용 학습 전에 @Transactional 어노테이션 동작 원리에 대한 질문을 듣게 되어 찾아 보았다. </br>
내부적으로 AOP 기술을 통해 트랜잭션 처리코드가 비즈니스 로직의 전,후로 수행 되도록 구현된다. </br>
(* AOP 는 비즈니스 로직과 함께 존재하는 공통된 부가기능 코드를 프록시 패턴을 이용해 분리해주는 기술이다.) </br>
- 트랜잭션 처리는 동적 프록시 객체에게 대신 위임하고, 동적 프록시 객체는 원래 타깃이 상속하고 있던 인터페이스를 상속하여 오버라이드 한 메서드 내부에서 타킷 메서드 호출 전, 후로 트랜잭션 처리 로직을 수행한다.
- @Transactional 어노테이션을 달아주면, 포인트 컷 정보로 등록된다. 
- 빈 후처리기라는 곳에서 생성된 빈마다 어드바이스를 부여할 수 있는지 여부를 포인트 컷으로 판단한다. 
- 부여가 가능하다면 동적 프록시 객체를 생성해서, 타깃 빈을 반환할 때 실제 타깃이 아닌 프록시 객체로 바꿔치기하여 반환해준다.

이후 내용 학습 후 업데이트 예정...
